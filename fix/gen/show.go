package gen

import (
	"fmt"
	"text/template"
)

func GenShow() ([]byte, error) {
	var types []any
	for _, u := range Unsigneds {
		types = append(types, u)
	}
	for _, s := range Signeds {
		types = append(types, s)
	}
	return execAndFmt(showTmpl, struct {
		Types []any
		Ops   []string
	}{
		Types: types,
		Ops:   []string{"SAdd", "SSub", "SMul"},
	})
}

var showTmpl = template.Must(template.New("show").Funcs(template.FuncMap{
	"opchar": func(s string) (string, error) {
		o, ok := map[string]string{
			"SAdd": "+",
			"SSub": "-",
			"SMul": "*",
		}[s]
		if !ok {
			return "", fmt.Errorf("unknown op %q", s)
		}
		return o, nil
	},
}).Parse(`
// This file contains example functions converting and operating on fix types
// and printing the results.
// Code generated by github.com/pfcm/fix/gen DO NOT EDIT.

package main

import (
	"fmt"
	"io"

	"github.com/pfcm/fxp/fix"
)

// typeKeys provides all the type names in a stable ordering, for consistent
// iteration over the conversions and ops maps.
var typeKeys = []string{
	{{range .Types -}}
	"{{.Typename}}",
	{{end -}}
}

// opKeys provides all the op names in a stable ordering, for consistent iteration.
var opKeys = []string {
	{{range .Ops -}}
	"{{.}}",
	{{end -}}
}

// conversions provides functions that show a particular input pattern converted
// to the various fix types, and using the generated conversions between
// the fix types. It is keyed by type name.
var conversions = map[string][]func(io.Writer, int64) {
{{range $a := .Types }}
	"{{$a.Typename}}": []func(io.Writer, int64) {
		func(w io.Writer, i int64) {
			show{{if $a.Signed}}S{{else}}Uns{{end}}igned(w, "{{$a.Typename}}", fix.{{$a.Typename}}(i))
		},
		{{range $b := $.Types -}}
		{{if eq $a $b}}{{continue}}{{end -}}
		func(w io.Writer, i int64) {
			show{{if $b.Signed}}S{{else}}Uns{{end}}igned(w, "{{$a.Typename}}To{{$b.Typename}}", fix.{{$a.Typename}}To{{$b.Typename}}(fix.{{$a.Typename}}(i)))
		},
		{{end -}}
	},
{{end}}
}

// ops provides operations between the various fix types. It is keyed
// first by the first type and then by the op.
var ops = map[string]map[string][]func(io.Writer, int64, int64) {
	{{range $a := .Types -}}
	"{{$a.Typename}}": {
		{{range $op := $.Ops -}}
		"{{$op}}": []func(io.Writer, int64, int64) {
			{{range $b := $.Types -}}
			func(w io.Writer, i, j int64) {
				show{{if $a.Signed}}S{{else}}Uns{{end}}igned(
					w, "{{$a.Typename}} {{opchar $op}} {{$b.Typename}}",
					{{if eq $a $b -}}
					fix.{{$a.Typename}}(i).{{$op}}(fix.{{$a.Typename}}(j)),
					{{else -}}
					fix.{{$a.Typename}}(i).{{$op}}{{$b.Typename}}(fix.{{$b.Typename}}(j)),
					{{end -}}
				)
			},
			{{end -}}
		},
		{{end -}}
	},
	{{end -}}
}

func showUnsigned[U ~uint8](w io.Writer, name string, u U) {
	fmt.Fprintf(w, "%s:\t%v\t%d\t0x%02x\t0b%08b\n", name, u, u, uint8(u), u)
}

func showSigned[S ~int8](w io.Writer, name string, s S) {
	sign := ""
	if s < 0 {
		sign = "-"
	}
	fmt.Fprintf(w, "%s:\t%v\t%d\t%s0x%02x\t0b%08b\n",
		name, s, s, sign, abs(int(s)), uint8(s))
}

func abs(i int) int { return max(i, -i) }
`))
