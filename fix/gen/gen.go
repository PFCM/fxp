// package gen provides some helpers for generating fixed point data types
// and benchmarks etc.
package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"math"
	"text/template"
)

// GenPairs generates operations that work on two different fixed point types,
// for each pair of types across both Signeds and Unsigneds.
func GenPairs() ([]byte, error) {
	type Type interface {
		Typename() string
	}
	var all []Type
	for _, u := range Unsigneds {
		all = append(all, u)
	}
	for _, s := range Signeds {
		all = append(all, s)
	}
	return execAndFmt(pairwiseTmpl, all)
}

// Unsigneds are the unsigned fixed point types to generate.
var Unsigneds = []Unsigned{{
	Frac:    8,
	Comment: "Especially useful for scaling and interpolation.",
}, {
	Frac:    7,
	Comment: "It is handy for gains and some other coefficients.",
}, {
	Frac:    6,
	Comment: "Also occasionally useful for coefficients.",
}, {
	Frac:    1,
	Comment: "Covers the usual range of MIDI notes, with half a step in between.",
}, {
	Frac:    0,
	Comment: "It is just a standard uint8, but with saturating arithmetic and generated conversions",
}}

// Unsigned represent an unsigned fixed-point data type.
type Unsigned struct {
	Frac int // Frac is the number of fractional bits.
	// Comment is an additional line of text to be added
	// to the doc comment.
	Comment string
}

func (u Unsigned) Typename() string {
	return fmt.Sprintf("U%d%d", 8-u.Frac, u.Frac)
}

func (u Unsigned) Signed() bool { return false }
func (u Unsigned) Min() float64 { return 0 }
func (u Unsigned) Max() float64 {
	return float64(0xff) / float64(int(1)<<u.Frac)
}

func (u Unsigned) Scale() int            { return 1 << u.Frac }
func (u Unsigned) InverseScale() float64 { return 1.0 / float64(u.Scale()) }

// Resolution returns the step between successive values.
func (u Unsigned) Resolution() float64 {
	return u.Max() / 256
}

// HalfResolution returns half of the step between successive values, used in
// rounding.
func (u Unsigned) HalfResolution() float64 {
	return u.Max() / 512
}

// Gen generates the implementation.
func (u Unsigned) Gen() ([]byte, error) {
	return execAndFmt(unsignedImplTmpl, u)
}

// GenTest generates some simple tests and benchmarks.
func (u Unsigned) GenTest() ([]byte, error) {
	return execAndFmt(typeTestTmpl, u)
}

func execAndFmt(tmpl *template.Template, d any) ([]byte, error) {
	var b bytes.Buffer
	if err := tmpl.Execute(&b, d); err != nil {
		return nil, fmt.Errorf("executing template: %w", err)
	}
	out, err := format.Source(b.Bytes())
	if err != nil {
		fmt.Println(b.String())
		return nil, fmt.Errorf("formatting: %w", err)
	}
	return out, nil
}

var unsignedImplTmpl = template.Must(template.New("unsigned").Funcs(template.FuncMap{
	"decwidth": func(i int) int {
		return max(1, int(math.Log10(float64(int(1)<<i))/math.Log10(2)))
	},
}).Parse(`
// Code generated by by github.com/pfcm/fxp/fix/gen DO NOT EDIT.

package fix

import (
	"fmt"

	"golang.org/x/exp/constraints"
)

// {{.Typename}} is an unsigned 8 bit fixed point number with {{.Frac}}
// fractional bits, representing numbers between 0 and {{.Max}}, in steps
// of {{.Resolution}}.
{{if .Comment -}}
// {{.Comment}}
{{end -}}
type {{.Typename}} uint8

const (
	// Min{{.Typename}} is the smallest {{.Typename}}: 0.
	Min{{.Typename}} {{.Typename}} = 0x00
	// Max{{.Typename}} is the largest {{.Typename}}: {{.Max}}.
	Max{{.Typename}} {{.Typename}} = 0xff
)

// {{.Typename}}ToFloat converts a {{.Typename}} to a float value.
func {{.Typename}}ToFloat[T constraints.Float](u {{.Typename}}) T {
	return T(u) * {{.InverseScale}}
}


// {{.Typename}}FromFloat returns the nearest {{.Typename}} to the provided
// float value.
func {{.Typename}}FromFloat[T constraints.Float](f T) {{.Typename}} {
	if f < 0 {
		return 0
	}
	if f > {{.Max}} {
		return 0xff
	}
	// TODO: rounding? Then we would have to do it in SMul etc.
	return {{.Typename}}((f/*+{{.HalfResolution}}*/) * {{.Scale}})
}

// String returns a string representation of a {{.Typename}}.
func (u {{.Typename}}) String() string {
	return fmt.Sprintf("%.{{decwidth .Frac}}f", {{.Typename}}ToFloat[float64](u))
}

// SAdd is a saturating addition betwenn two {{.Typename}}.
func (u {{.Typename}}) SAdd(v {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(usadd(uint8(u), uint8(v)))
}

// SSub is a saturating subtraction between two {{.Typename}},
// subtracting v from u.
func (u {{.Typename}}) SSub(v {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(ussub(uint8(u), uint8(v)))
}

// SMul is a saturating multiply between two {{.Typename}}.
func (u {{.Typename}}) SMul(v {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(usmul(uint8(u), uint8(v), {{.Frac}}))
}
`))

var typeTestTmpl = template.Must(template.New("test").Funcs(template.FuncMap{
	"loop": func(t any, i string) (string, error) {
		switch t.(type) {
		case Unsigned:
			return fmt.Sprintf("for %s := 0; %s < 256; %s++", i, i, i), nil
		case Signed:
			return fmt.Sprintf("for %s := -128; %s < 128; %s++", i, i, i), nil
		}
		return "", fmt.Errorf("unknown type %T for loop", t)
	},
}).Parse(`
// Code generated by by github.com/pfcm/fxp/fix/gen DO NOT EDIT.

package fix

import (
	"math/rand"
	"testing"
)

func Test{{.Typename}}FloatRoundTrip(t *testing.T) {
	{{loop . "i"}} {
		u := {{.Typename}}(i)
		f := {{.Typename}}ToFloat[float64](u)
		u2 := {{.Typename}}FromFloat(f)
		if u != u2 {
			t.Errorf("FromFloat(ToFloat(%x)) = %x", u, u2)
		}
	}
}

func Test{{.Typename}}Ops(t *testing.T) {
	// The actual implementations of these are tested pretty thoroughly
	// so all we need to do here it make sure that the generated code
	// appears to be using them correctly.
	var as, bs [256]{{.Typename}}
	for i := range as {
		as[i] = {{.Typename}}(i)
		bs[i] = {{.Typename}}(i)
	}
	shuffle := func() {
		rand.Shuffle(256, func(i, j int) { as[i], as[j] = as[j], as[i] })
		rand.Shuffle(256, func(i, j int) { bs[i], bs[j] = bs[j], bs[i] })
	}
	test := func(t *testing.T, name string, f func({{.Typename}}, {{.Typename}}) {{.Typename}}, h func(float64, float64) float64) {
		t.Helper()
		for range 10 {
			shuffle()
			for i, a := range as {
				b := bs[i]
				af := {{.Typename}}ToFloat[float64](a)
				bf := {{.Typename}}ToFloat[float64](b)
				wantf := h(af, bf)
				want := {{.Typename}}FromFloat(wantf)
				got := f(a, b)
				// We don't necessarily expect them to be
				// identical just because of rounding etc.,
				// it's ok if it's only off by one step.
				d := max(got, want) - min(got, want)
				if d > 1 {
					t.Errorf("%v.%s(%v) (%x.%s(%x)) = %v (%x), want: %v (%x)", a, name, b, uint8(a), name, uint8(b), got, uint8(got), want, uint8(want))
				}
			}
		}
	}
	t.Run("SAdd", func(t *testing.T) {
		test(t, "SAdd", {{.Typename}}.SAdd, func(a, b float64) float64 {
			x := a + b
			if x < {{.Min}} {
				return {{.Min}}
			}
			if x > {{.Max}} {
				return {{.Max}}
			}
			return x
		})
	})
	t.Run("SSub", func(t *testing.T) {
		test(t, "SSub", {{.Typename}}.SSub, func(a, b float64) float64 {
			x := a - b
			if x < {{.Min}} {
				return {{.Min}}
			}
			if x > {{.Max}} {
				return {{.Max}}
			}
			return x
		})
	})
	t.Run("SMul", func(t *testing.T) {
		test(t, "SMul", {{.Typename}}.SMul, func(a, b float64) float64 {
			x := a * b
			if x < {{.Min}} {
				return {{.Min}}
			}
			if x > {{.Max}} {
				return {{.Max}}
			}
			return x
		})
	})
}
`))

var Signeds = []Signed{{
	Frac:    7,
	Comment: "Used primarily for audio samples.",
}, {
	Frac:    6,
	Comment: "Handy for some signed coefficients.",
}, {
	Frac:    0,
	Comment: "It is just a standard int8, but with saturating arithmetic and all the generated conversions.",
}}

type Signed struct {
	Frac    int
	Comment string
}

func (s Signed) Typename() string {
	return fmt.Sprintf("S%d%d", 8-s.Frac, s.Frac)
}

func (s Signed) Max() float64 {
	return float64(0x7f) / float64(s.Scale())
}

func (s Signed) Min() float64 {
	return float64(-0x80) / float64(s.Scale())
}

func (s Signed) Signed() bool          { return true }
func (s Signed) Scale() int            { return 1 << s.Frac }
func (s Signed) InverseScale() float64 { return 1.0 / float64(s.Scale()) }

func (s Signed) Resolution() float64 {
	return (s.Max() - s.Min()) / 256
}

// HalfResolution returns half of the step between successive values, used in
// rounding.
func (s Signed) HalfResolution() float64 {
	return (s.Max() - s.Min()) / 512
}

// Gen generates the implementation.
func (s Signed) Gen() ([]byte, error) {
	return execAndFmt(signedImplTmpl, s)
}

// GenTest generates a file with some tests.
func (s Signed) GenTest() ([]byte, error) {
	return execAndFmt(typeTestTmpl, s)
}

var signedImplTmpl = template.Must(template.New("signed").Funcs(template.FuncMap{
	"decwidth": func(i int) int {
		return max(1, int(math.Log10(float64(int(1)<<i))/math.Log10(2)))
	},
}).Parse(`
// Code generated by github.com/pfcm/fix/gen DO NOT EDIT.

package fix

import (
	"fmt"

	"golang.org/x/exp/constraints"
)

// {{.Typename}} is a signed 8 bit fixed point number with {{.Frac}}
// fractional bits, representing numbers between {{.Min}} and {{.Max}}
// in steps of {{.Resolution}}.
{{if .Comment -}}
// {{.Comment}}
{{end -}}
type {{.Typename}} int8

const (
	// Min{{.Typename}} is the smallest {{.Typename}}: {{.Min}}.
	Min{{.Typename}} {{.Typename}} = -0x80
	// Max{{.Typename}} is the largest {{.Typename}}: {{.Max}}.
	Max{{.Typename}} {{.Typename}} = 0x7f
)

// {{.Typename}}ToFloat converts a {{.Typename}} to a float value.
func {{.Typename}}ToFloat[T constraints.Float](u {{.Typename}}) T {
	return T(u) * {{.InverseScale}}
}

// {{.Typename}}FromFloat creates a {{.Typename}} from a float value.
func {{.Typename}}FromFloat[T constraints.Float](f T) {{.Typename}} {
	if f < {{.Min}} {
		return -0x80
	}
	if f > {{.Max}} {
		return 0x7f
	}
	// TODO: rounding?
	return {{.Typename}}((f/**{{.HalfResolution}}*/) * {{.Scale}})
}

// String returns a string representation of a {{.Typename}}.
func (s {{.Typename}}) String() string {
	return fmt.Sprintf("%.{{decwidth .Frac}}f", {{.Typename}}ToFloat[float64](s))
}

// SAdd is a saturating addition between two {{.Typename}}.
func (s {{.Typename}}) SAdd(t {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(ssadd(int8(s), int8(t)))
}

// SSub is a saturating subtraction between two {{.Typename}},
// subtracting t from s.
func (s {{.Typename}}) SSub(t {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(sssub(int8(s), int8(t)))
}

// SMul is a saturating multiple between two {{.Typename}}.
func (s {{.Typename}}) SMul(t {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(ssmul(int8(s), int8(t), {{.Frac}}))
}
`))

var pairwiseTmpl = template.Must(template.New("pairs").Funcs(template.FuncMap{
	"absdiff": func(a, b int) int {
		return max(a, b) - min(a, b)
	},
	"pluralise": func(s string, n int) string {
		if n == 1 {
			return s
		}
		return s + "s"
	},
	"dirshift": func(a, b int) string {
		s := a - b
		if s == 0 {
			return ""
		}
		if s < 0 {
			return fmt.Sprintf(">> %d", -s)
		}
		return fmt.Sprintf("<< %d", s)
	},
}).Parse(`
// This package contains operations on mismatched fixed point types.
// Code generated by github.com/pfcm/fix/gen DO NOT EDIT.

package fix

{{range $a := $ }}
{{range $b := $ }}
{{if eq $a $b}}{{continue}}{{end}}
////////////////////////////////////////////////////////////////////////////////
// begin ({{$a.Typename}}, {{$b.Typename}}) -> {{$a.Typename}}

// {{$b.Typename}}To{{$a.Typename}} converts a {{$b.Typename}} to a {{$a.Typename}}.
{{if lt $a.Frac $b.Frac -}}
// {{$a.Typename}} has fewer fractional bits and therefore a wider range, so the
// result will be between {{$b.Min}} and {{$b.Max}} (rounding to a valid {{$a.Typename}}
// towards zero).
{{else if gt $a.Frac $b.Frac -}}
// {{$a.Typename}} has more fractional bits and therefore a narrower range, so the
// result will be capped between {{$a.Min}} and {{$a.Max}}.
{{else if $a.Signed -}}
// The two types have the same number of fractional bits, but as {{$a.Typename}} is
// signed and {{$b.Typename}} is not, the result will be positive but truncated
// at {{$a.Max}}.
{{else -}}
// The two types have the same number of fractional bits, but as {{$a.Typename}} is
// not signed and {{$b.Typename}} is, the result will be clipped between {{$a.Min}}
// and {{$b.Max}}.
{{end -}}
func {{$b.Typename}}To{{$a.Typename}}(b {{$b.Typename}}) {{$a.Typename}} {
	{{if and $a.Signed $b.Signed -}}
	return {{$a.Typename}}(b){{dirshift $a.Frac $b.Frac}}
	{{else if not $a.Signed | and $b.Signed -}}
	// {{$a.Typename}} is not signed, {{$b.Typename}} is.
	// We can't represent a negative b, so cut that off at 0.
	if b < 0 {
		return Min{{$a.Typename}}
	}
	return {{$a.Typename}}(b){{dirshift $a.Frac $b.Frac}}
	{{ else if not $b.Signed | and $a.Signed -}}
	{{if ge $a.Frac $b.Frac -}}
	// {{$a.Typename}} has a narrower range than {{$b.Typename}}.
	m := 0xff << (8-{{absdiff $a.Frac $b.Frac}}-1)
	if b&{{$b.Typename}}(m) != 0 {
		return Max{{$a.Typename}}
	}
	{{end -}}
	r := {{$a.Typename}}(b{{dirshift $a.Frac $b.Frac}})
	// TODO: we don't need to do this if we shifted right.
	if r < 0 {
		r = 0
	}
	return r
	{{else -}}
	{{if gt $a.Frac $b.Frac -}}
	// {{$a.Typename}} has fewer integer bits and therefore a narrower range
	// than {{$b.Typename}}. If anything we're about to shift off is not zero,
	// then we can't represent b and need to use the maximum.
	m := 0xff << (8-{{absdiff $a.Frac $b.Frac}})
	if b&{{$b.Typename}}(m) != 0 {
		return Max{{$a.Typename}}
	}
	{{end -}}
	return {{$a.Typename}}(b){{dirshift $a.Frac $b.Frac}}
	{{end -}}
}

// SAdd{{$b.Typename}} adds a {{$a.Typename}} and a {{$b.Typename}}, storing the
// result in a {{$a.Typename}}.
func (a {{$a.Typename}}) SAdd{{$b.Typename}}(b {{$b.Typename}}) {{$a.Typename}} {
	{{if not $a.Signed | and $b.Signed -}}
	// If b is negative, try and subtract its absolute value,
	// or as close as we can get.
	if b == Min{{$b.Typename}} {
		// SSub(-b) won't work, because this is the one number where
		// -b = b (so {{$b.Typename}}To{{$a.Typename}}(-b) = 0).
		// TODO: we probably don't always need to sub the extra 1?
		return a.SSub({{$b.Typename}}To{{$a.Typename}}(Max{{$b.Typename}})).SSub(1)
	}
	if b < 0 {
		return a.SSub({{$b.Typename}}To{{$a.Typename}}(-b))
	}
	{{end -}}
	return a.SAdd({{$b.Typename}}To{{$a.Typename}}(b))
}

func (a {{$a.Typename}}) SSub{{$b.Typename}}(b {{$b.Typename}}) {{$a.Typename}} {
	{{if not $a.Signed | and $b.Signed -}}
	// If b is negative, try and subtract its absolute value,
	// or as close as we can get.
	if b == Min{{$b.Typename}} {
		// SAdd(-b) won't work, because this is the one number where
		// -b = b (so {{$b.Typename}}To{{$a.Typename}}(-b) = 0).
		// TODO: is this correction always necessary?
		return a.SAdd({{$b.Typename}}To{{$a.Typename}}(Max{{$b.Typename}})).SAdd(1)
	}
	// If b is negative, add its absolute value instead.
	if b < 0 {
		return a.SAdd({{$b.Typename}}To{{$a.Typename}}(-b))
	}
	{{else if not $b.Signed | and $a.Signed -}}
	{{if ge $a.Frac $b.Frac -}}
	m := 0xff << (8-{{absdiff $a.Frac $b.Frac}} - 1)
	if b&{{$b.Typename}}(m) != 0 {
		// Direct conversion will saturate, which means the result
		// will be wrong. To get the right answer (or as close as
		// we can) break the subtraction into two pieces. Two is
		// always enough because the largest possible value we can
		// subtract is the Min{{$a.Typename}}, which covers more than
		// half of the possible range of possible {{$a.Typename}}.
		a = a.SAdd(Min{{$a.Typename}})
		b = b.SAdd{{$a.Typename}}(Min{{$a.Typename}})
	}
	{{end -}}
	{{end -}}
	return a.SSub({{$b.Typename}}To{{$a.Typename}}(b))
}

// SMul{{$b.Typename}} performs a saturating multiply between a {{$a.Typename}}
// and a {{$b.Typename}}, returning the result in a {{$a.Typename}}.
{{if not $a.Signed | and $b.Signed -}}
// As {{$a.Typename}} is always positive, if b is negative the result will always
// be truncated to 0.
{{end -}}
func (a {{$a.Typename}}) SMul{{$b.Typename}}(b {{$b.Typename}}) {{$a.Typename}} {
	{{if or $a.Signed $b.Signed | not -}}
	return {{$a.Typename}}(usmul2(uint8(a), {{$a.Frac}}, uint8(b), {{$b.Frac}}))
	{{else if and $a.Signed $b.Signed -}}
	return {{$a.Typename}}(ssmul2(int8(a), {{$a.Frac}}, int8(b), {{$b.Frac}}))
	{{else if $a.Signed -}}
	return {{$a.Typename}}(susmul2(int8(a), {{$a.Frac}}, uint8(b), {{$b.Frac}}))
	{{else -}}
	return {{$a.Typename}}(ussmul2(uint8(a), {{$a.Frac}}, int8(b), {{$b.Frac}}))
	{{end -}}
}

// end ({{$a.Typename}}, {{$b.Typename}}) -> {{$a.Typename}}
////////////////////////////////////////////////////////////////////////////////
{{end}}
{{end}}
`))
