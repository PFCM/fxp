// package gen provides some helpers for generating fixed point data types
// and benchmarks etc.
package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"math"
	"text/template"
)

// Unsigneds are the unsigned fixed point types to generate.
var Unsigneds = []Unsigned{{
	Frac:    8,
	Comment: "Especially useful for scaling and interpolation.",
}, {
	Frac:    7,
	Comment: "It is handy for gains and some other coefficients.",
}, {
	Frac:    1,
	Comment: "Covers the usual range of MIDI notes, with half a step in between.",
}}

// Unsigned represent an unsigned fixed-point data type.
type Unsigned struct {
	Frac int // Frac is the number of fractional bits.
	// Comment is an additional line of text to be added
	// to the doc comment.
	Comment string
}

func (u Unsigned) Typename() string {
	return fmt.Sprintf("U%d%d", 8-u.Frac, u.Frac)
}

func (u Unsigned) Min() float64 { return 0 }
func (u Unsigned) Max() float64 {
	return float64(0xff) / float64(int(1)<<u.Frac)
}

func (u Unsigned) Scale() int            { return 1 << u.Frac }
func (u Unsigned) InverseScale() float64 { return 1.0 / float64(u.Scale()) }

// Resolution returns the step between successive values.
func (u Unsigned) Resolution() float64 {
	return u.Max() / 256
}

// HalfResolution returns half of the step between successive values, used in
// rounding.
func (u Unsigned) HalfResolution() float64 {
	return u.Max() / 512
}

// Gen generates the implementation.
func (u Unsigned) Gen() ([]byte, error) {
	return execAndFmt(unsignedImplTmpl, u)
}

// GenTest generates some simple tests and benchmarks.
func (u Unsigned) GenTest() ([]byte, error) {
	return execAndFmt(typeTestTmpl, u)
}

func execAndFmt(tmpl *template.Template, d any) ([]byte, error) {
	var b bytes.Buffer
	if err := tmpl.Execute(&b, d); err != nil {
		return nil, fmt.Errorf("executing template: %w", err)
	}
	out, err := format.Source(b.Bytes())
	if err != nil {
		fmt.Println(b.String())
		return nil, fmt.Errorf("formatting: %w", err)
	}
	return out, nil
}

var unsignedImplTmpl = template.Must(template.New("unsigned").Funcs(template.FuncMap{
	"decwidth": func(i int) int {
		return max(1, int(math.Log10(float64(int(1)<<i))/math.Log10(2)))
	},
}).Parse(`
// Code generated by by github.com/pfcm/fxp/fix/gen DO NOT EDIT.

package fix

import (
	"fmt"

	"golang.org/x/exp/constraints"
)

// {{.Typename}} is an unsigned 8 bit fixed point number with {{.Frac}}
// fractional bits, representing numbers between 0 and {{.Max}}, in steps
// of {{.Resolution}}.
{{if .Comment -}}
// {{.Comment}}
{{end -}}
type {{.Typename}} uint8

const (
	// Min{{.Typename}} is the smallest {{.Typename}}: 0.
	Min{{.Typename}} {{.Typename}} = 0x00
	// Max{{.Typename}} is the largest {{.Typename}}: {{.Max}}.
	Max{{.Typename}} {{.Typename}} = 0xff
)

// {{.Typename}}ToFloat converts a {{.Typename}} to a float value.
func {{.Typename}}ToFloat[T constraints.Float](u {{.Typename}}) T {
	return T(u) * {{.InverseScale}}
}


// {{.Typename}}FromFloat returns the nearest {{.Typename}} to the provided
// float value.
func {{.Typename}}FromFloat[T constraints.Float](f T) {{.Typename}} {
	if f < 0 {
		return 0
	}
	if f > {{.Max}} {
		return 0xff
	}
	// TODO: rounding? Then we would have to do it in SMul etc.
	return {{.Typename}}((f/*+{{.HalfResolution}}*/) * {{.Scale}})
}

// String returns a string representation of a {{.Typename}}.
func (u {{.Typename}}) String() string {
	return fmt.Sprintf("%.{{decwidth .Frac}}f", {{.Typename}}ToFloat[float64](u))
}

// SAdd is a saturating addition betwenn two {{.Typename}}.
func (u {{.Typename}}) SAdd(v {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(usadd(uint8(u), uint8(v)))
}

// SSub is a saturating subtraction between two {{.Typename}},
// subtracting v from u.
func (u {{.Typename}}) SSub(v {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(ussub(uint8(u), uint8(v)))
}

// SMul is a saturating multiply between two {{.Typename}}.
func (u {{.Typename}}) SMul(v {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(usmul(uint8(u), uint8(v), {{.Frac}}))
}
`))

var typeTestTmpl = template.Must(template.New("test").Funcs(template.FuncMap{
	"loop": func(t any, i string) (string, error) {
		switch t.(type) {
		case Unsigned:
			return fmt.Sprintf("for %s := 0; %s < 256; %s++", i, i, i), nil
		case Signed:
			return fmt.Sprintf("for %s := -128; %s < 128; %s++", i, i, i), nil
		}
		return "", fmt.Errorf("unknown type %T for loop", t)
	},
}).Parse(`
// Code generated by by github.com/pfcm/fxp/fix/gen DO NOT EDIT.

package fix

import (
	"math/rand"
	"testing"
)

func Test{{.Typename}}FloatRoundTrip(t *testing.T) {
	{{loop . "i"}} {
		u := {{.Typename}}(i)
		f := {{.Typename}}ToFloat[float64](u)
		u2 := {{.Typename}}FromFloat(f)
		if u != u2 {
			t.Errorf("FromFloat(ToFloat(%x)) = %x", u, u2)
		}
	}
}

func Test{{.Typename}}Ops(t *testing.T) {
	// The actual implementations of these are tested pretty thoroughly
	// so all we need to do here it make sure that the generated code
	// appears to be using them correctly.
	var as, bs [256]{{.Typename}}
	for i := range as {
		as[i] = {{.Typename}}(i)
		bs[i] = {{.Typename}}(i)
	}
	shuffle := func() {
		rand.Shuffle(256, func(i, j int) { as[i], as[j] = as[j], as[i] })
		rand.Shuffle(256, func(i, j int) { bs[i], bs[j] = bs[j], bs[i] })
	}
	test := func(t *testing.T, name string, f func({{.Typename}}, {{.Typename}}) {{.Typename}}, h func(float64, float64) float64) {
		t.Helper()
		for range 10 {
			shuffle()
			for i, a := range as {
				b := bs[i]
				af := {{.Typename}}ToFloat[float64](a)
				bf := {{.Typename}}ToFloat[float64](b)
				wantf := h(af, bf)
				want := {{.Typename}}FromFloat(wantf)
				got := f(a, b)
				// We don't necessarily expect them to be
				// identical just because of rounding etc.,
				// it's ok if it's only off by one step.
				d := max(got, want) - min(got, want)
				if d > 1 {
					t.Errorf("%v.%s(%v) (%x.%s(%x)) = %v (%x), want: %v (%x)", a, name, b, uint8(a), name, uint8(b), got, uint8(got), want, uint8(want))
				}
			}
		}
	}
	t.Run("SAdd", func(t *testing.T) {
		test(t, "SAdd", {{.Typename}}.SAdd, func(a, b float64) float64 {
			x := a + b
			if x < {{.Min}} {
				return {{.Min}}
			}
			if x > {{.Max}} {
				return {{.Max}}
			}
			return x
		})
	})
	t.Run("SSub", func(t *testing.T) {
		test(t, "SSub", {{.Typename}}.SSub, func(a, b float64) float64 {
			x := a - b
			if x < {{.Min}} {
				return {{.Min}}
			}
			if x > {{.Max}} {
				return {{.Max}}
			}
			return x
		})
	})
	t.Run("SMul", func(t *testing.T) {
		test(t, "SMul", {{.Typename}}.SMul, func(a, b float64) float64 {
			x := a * b
			if x < {{.Min}} {
				return {{.Min}}
			}
			if x > {{.Max}} {
				return {{.Max}}
			}
			return x
		})
	})
}
`))

var Signeds = []Signed{{
	Frac:    7,
	Comment: "Used primarily for audio samples.",
}}

type Signed struct {
	Frac    int
	Comment string
}

func (s Signed) Typename() string {
	return fmt.Sprintf("S%d%d", 8-s.Frac, s.Frac)
}

func (s Signed) Max() float64 {
	return float64(0x7f) / float64(s.Scale())
}

func (s Signed) Min() float64 {
	return float64(-0x80) / float64(s.Scale())
}

func (s Signed) Scale() int            { return 1 << s.Frac }
func (s Signed) InverseScale() float64 { return 1.0 / float64(s.Scale()) }

func (s Signed) Resolution() float64 {
	return (s.Max() - s.Min()) / 256
}

// HalfResolution returns half of the step between successive values, used in
// rounding.
func (s Signed) HalfResolution() float64 {
	return (s.Max() - s.Min()) / 512
}

// Gen generates the implementation.
func (s Signed) Gen() ([]byte, error) {
	return execAndFmt(signedImplTmpl, s)
}

// GenTest generates a file with some tests.
func (s Signed) GenTest() ([]byte, error) {
	return execAndFmt(typeTestTmpl, s)
}

var signedImplTmpl = template.Must(template.New("signed").Funcs(template.FuncMap{
	"decwidth": func(i int) int {
		return max(1, int(math.Log10(float64(int(1)<<i))/math.Log10(2)))
	},
}).Parse(`
// Code generated by github.com/pfcm/fix/gen DO NOT EDIT.

package fix

import (
	"fmt"

	"golang.org/x/exp/constraints"
)

// {{.Typename}} is a signed 8 bit fixed point number with {{.Frac}}
// fractional bits, representing numbers between {{.Min}} and {{.Max}}
// in steps of {{.Resolution}}.
{{if .Comment -}}
// {{.Comment}}
{{end -}}
type {{.Typename}} int8

const (
	// Min{{.Typename}} is the smallest {{.Typename}}: {{.Min}}.
	Min{{.Typename}} {{.Typename}} = -0x80
	// Max{{.Typename}} is the largest {{.Typename}}: {{.Max}}.
	Max{{.Typename}} {{.Typename}} = 0x7f
)

// {{.Typename}}ToFloat converts a {{.Typename}} to a float value.
func {{.Typename}}ToFloat[T constraints.Float](u {{.Typename}}) T {
	return T(u) * {{.InverseScale}}
}

// {{.Typename}}FromFloat creates a {{.Typename}} from a float value.
func {{.Typename}}FromFloat[T constraints.Float](f T) {{.Typename}} {
	if f < {{.Min}} {
		return -0x80
	}
	if f > {{.Max}} {
		return 0x7f
	}
	// TODO: rounding?
	return {{.Typename}}((f/**{{.HalfResolution}}*/) * {{.Scale}})
}

// String returns a string representation of a {{.Typename}}.
func (s {{.Typename}}) String() string {
	return fmt.Sprintf("%.{{decwidth .Frac}}f", {{.Typename}}ToFloat[float64](s))
}

// SAdd is a saturating addition between two {{.Typename}}.
func (s {{.Typename}}) SAdd(t {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(ssadd(int8(s), int8(t)))
}

// SSub is a saturating subtraction between two {{.Typename}},
// subtracting t from s.
func (s {{.Typename}}) SSub(t {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(sssub(int8(s), int8(t)))
}

// SMul is a saturating multiple between two {{.Typename}}.
func (s {{.Typename}}) SMul(t {{.Typename}}) {{.Typename}} {
	return {{.Typename}}(ssmul(int8(s), int8(t), {{.Frac}}))
}
`))
