// This package contains operations on mismatched fixed point types.
// Code generated by github.com/pfcm/fix/gen DO NOT EDIT.

package fix

////////////////////////////////////////////////////////////////////////////////
// begin (U08, U17) -> U08

// U17ToU08 converts a U17 to a U08.
// U08 has more fractional bits and therefore a narrower range, so the
// result will be capped between 0 and 0.99609375.
func U17ToU08(b U17) U08 {
	// U08 has fewer integer bits and therefore a narrower range
	// than U17. If anything we're about to shift off is not zero,
	// then we can't represent b and need to use the maximum.
	m := 0xff << (8 - 1)
	if b&U17(m) != 0 {
		return MaxU08
	}
	return U08(b) << 1
}

// SAddU17 adds a U08 and a U17, storing the
// result in a U08.
func (a U08) SAddU17(b U17) U08 {
	return a.SAdd(U17ToU08(b))
}

func (a U08) SSubU17(b U17) U08 {
	return a.SSub(U17ToU08(b))
}

// SMulU17 performs a saturating multiply between a U08
// and a U17, returning the result in a U08.
func (a U08) SMulU17(b U17) U08 {
	return U08(usmul2(uint8(a), 8, uint8(b), 7))
}

// end (U08, U17) -> U08
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (U08, U71) -> U08

// U71ToU08 converts a U71 to a U08.
// U08 has more fractional bits and therefore a narrower range, so the
// result will be capped between 0 and 0.99609375.
func U71ToU08(b U71) U08 {
	// U08 has fewer integer bits and therefore a narrower range
	// than U71. If anything we're about to shift off is not zero,
	// then we can't represent b and need to use the maximum.
	m := 0xff << (8 - 7)
	if b&U71(m) != 0 {
		return MaxU08
	}
	return U08(b) << 7
}

// SAddU71 adds a U08 and a U71, storing the
// result in a U08.
func (a U08) SAddU71(b U71) U08 {
	return a.SAdd(U71ToU08(b))
}

func (a U08) SSubU71(b U71) U08 {
	return a.SSub(U71ToU08(b))
}

// SMulU71 performs a saturating multiply between a U08
// and a U71, returning the result in a U08.
func (a U08) SMulU71(b U71) U08 {
	return U08(usmul2(uint8(a), 8, uint8(b), 1))
}

// end (U08, U71) -> U08
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (U08, S17) -> U08

// S17ToU08 converts a S17 to a U08.
// U08 has more fractional bits and therefore a narrower range, so the
// result will be capped between 0 and 0.99609375.
func S17ToU08(b S17) U08 {
	// U08 is not signed, S17 is.
	// We can't represent a negative b, so cut that off at 0.
	if b < 0 {
		return MinU08
	}
	return U08(b) << 1
}

// SAddS17 adds a U08 and a S17, storing the
// result in a U08.
func (a U08) SAddS17(b S17) U08 {
	// If b is negative, try and subtract its absolute value,
	// or as close as we can get.
	if b == MinS17 {
		// SSub(-b) won't work, because this is the one number where
		// -b = b (so S17ToU08(-b) = 0).
		// TODO: we probably don't always need to sub the extra 1?
		return a.SSub(S17ToU08(MaxS17)).SSub(1)
	}
	if b < 0 {
		return a.SSub(S17ToU08(-b))
	}
	return a.SAdd(S17ToU08(b))
}

func (a U08) SSubS17(b S17) U08 {
	// If b is negative, try and subtract its absolute value,
	// or as close as we can get.
	if b == MinS17 {
		// SAdd(-b) won't work, because this is the one number where
		// -b = b (so S17ToU08(-b) = 0).
		// TODO: is this correction always necessary?
		return a.SAdd(S17ToU08(MaxS17)).SAdd(1)
	}
	// If b is negative, add its absolute value instead.
	if b < 0 {
		return a.SAdd(S17ToU08(-b))
	}
	return a.SSub(S17ToU08(b))
}

// SMulS17 performs a saturating multiply between a U08
// and a S17, returning the result in a U08.
// As U08 is always positive, if b is negative the result will always
// be truncated to 0.
func (a U08) SMulS17(b S17) U08 {
	return U08(ussmul2(uint8(a), 8, int8(b), 7))
}

// end (U08, S17) -> U08
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (U17, U08) -> U17

// U08ToU17 converts a U08 to a U17.
// U17 has fewer fractional bits and therefore a wider range, so the
// result will be between 0 and 0.99609375 (rounding to a valid U17
// towards zero).
func U08ToU17(b U08) U17 {
	return U17(b) >> 1
}

// SAddU08 adds a U17 and a U08, storing the
// result in a U17.
func (a U17) SAddU08(b U08) U17 {
	return a.SAdd(U08ToU17(b))
}

func (a U17) SSubU08(b U08) U17 {
	return a.SSub(U08ToU17(b))
}

// SMulU08 performs a saturating multiply between a U17
// and a U08, returning the result in a U17.
func (a U17) SMulU08(b U08) U17 {
	return U17(usmul2(uint8(a), 7, uint8(b), 8))
}

// end (U17, U08) -> U17
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (U17, U71) -> U17

// U71ToU17 converts a U71 to a U17.
// U17 has more fractional bits and therefore a narrower range, so the
// result will be capped between 0 and 1.9921875.
func U71ToU17(b U71) U17 {
	// U17 has fewer integer bits and therefore a narrower range
	// than U71. If anything we're about to shift off is not zero,
	// then we can't represent b and need to use the maximum.
	m := 0xff << (8 - 6)
	if b&U71(m) != 0 {
		return MaxU17
	}
	return U17(b) << 6
}

// SAddU71 adds a U17 and a U71, storing the
// result in a U17.
func (a U17) SAddU71(b U71) U17 {
	return a.SAdd(U71ToU17(b))
}

func (a U17) SSubU71(b U71) U17 {
	return a.SSub(U71ToU17(b))
}

// SMulU71 performs a saturating multiply between a U17
// and a U71, returning the result in a U17.
func (a U17) SMulU71(b U71) U17 {
	return U17(usmul2(uint8(a), 7, uint8(b), 1))
}

// end (U17, U71) -> U17
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (U17, S17) -> U17

// S17ToU17 converts a S17 to a U17.
// The two types have the same number of fractional bits, but as U17 is
// not signed and S17 is, the result will be clipped between 0
// and 0.9921875.
func S17ToU17(b S17) U17 {
	// U17 is not signed, S17 is.
	// We can't represent a negative b, so cut that off at 0.
	if b < 0 {
		return MinU17
	}
	return U17(b)
}

// SAddS17 adds a U17 and a S17, storing the
// result in a U17.
func (a U17) SAddS17(b S17) U17 {
	// If b is negative, try and subtract its absolute value,
	// or as close as we can get.
	if b == MinS17 {
		// SSub(-b) won't work, because this is the one number where
		// -b = b (so S17ToU17(-b) = 0).
		// TODO: we probably don't always need to sub the extra 1?
		return a.SSub(S17ToU17(MaxS17)).SSub(1)
	}
	if b < 0 {
		return a.SSub(S17ToU17(-b))
	}
	return a.SAdd(S17ToU17(b))
}

func (a U17) SSubS17(b S17) U17 {
	// If b is negative, try and subtract its absolute value,
	// or as close as we can get.
	if b == MinS17 {
		// SAdd(-b) won't work, because this is the one number where
		// -b = b (so S17ToU17(-b) = 0).
		// TODO: is this correction always necessary?
		return a.SAdd(S17ToU17(MaxS17)).SAdd(1)
	}
	// If b is negative, add its absolute value instead.
	if b < 0 {
		return a.SAdd(S17ToU17(-b))
	}
	return a.SSub(S17ToU17(b))
}

// SMulS17 performs a saturating multiply between a U17
// and a S17, returning the result in a U17.
// As U17 is always positive, if b is negative the result will always
// be truncated to 0.
func (a U17) SMulS17(b S17) U17 {
	return U17(ussmul2(uint8(a), 7, int8(b), 7))
}

// end (U17, S17) -> U17
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (U71, U08) -> U71

// U08ToU71 converts a U08 to a U71.
// U71 has fewer fractional bits and therefore a wider range, so the
// result will be between 0 and 0.99609375 (rounding to a valid U71
// towards zero).
func U08ToU71(b U08) U71 {
	return U71(b) >> 7
}

// SAddU08 adds a U71 and a U08, storing the
// result in a U71.
func (a U71) SAddU08(b U08) U71 {
	return a.SAdd(U08ToU71(b))
}

func (a U71) SSubU08(b U08) U71 {
	return a.SSub(U08ToU71(b))
}

// SMulU08 performs a saturating multiply between a U71
// and a U08, returning the result in a U71.
func (a U71) SMulU08(b U08) U71 {
	return U71(usmul2(uint8(a), 1, uint8(b), 8))
}

// end (U71, U08) -> U71
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (U71, U17) -> U71

// U17ToU71 converts a U17 to a U71.
// U71 has fewer fractional bits and therefore a wider range, so the
// result will be between 0 and 1.9921875 (rounding to a valid U71
// towards zero).
func U17ToU71(b U17) U71 {
	return U71(b) >> 6
}

// SAddU17 adds a U71 and a U17, storing the
// result in a U71.
func (a U71) SAddU17(b U17) U71 {
	return a.SAdd(U17ToU71(b))
}

func (a U71) SSubU17(b U17) U71 {
	return a.SSub(U17ToU71(b))
}

// SMulU17 performs a saturating multiply between a U71
// and a U17, returning the result in a U71.
func (a U71) SMulU17(b U17) U71 {
	return U71(usmul2(uint8(a), 1, uint8(b), 7))
}

// end (U71, U17) -> U71
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (U71, S17) -> U71

// S17ToU71 converts a S17 to a U71.
// U71 has fewer fractional bits and therefore a wider range, so the
// result will be between -1 and 0.9921875 (rounding to a valid U71
// towards zero).
func S17ToU71(b S17) U71 {
	// U71 is not signed, S17 is.
	// We can't represent a negative b, so cut that off at 0.
	if b < 0 {
		return MinU71
	}
	return U71(b) >> 6
}

// SAddS17 adds a U71 and a S17, storing the
// result in a U71.
func (a U71) SAddS17(b S17) U71 {
	// If b is negative, try and subtract its absolute value,
	// or as close as we can get.
	if b == MinS17 {
		// SSub(-b) won't work, because this is the one number where
		// -b = b (so S17ToU71(-b) = 0).
		// TODO: we probably don't always need to sub the extra 1?
		return a.SSub(S17ToU71(MaxS17)).SSub(1)
	}
	if b < 0 {
		return a.SSub(S17ToU71(-b))
	}
	return a.SAdd(S17ToU71(b))
}

func (a U71) SSubS17(b S17) U71 {
	// If b is negative, try and subtract its absolute value,
	// or as close as we can get.
	if b == MinS17 {
		// SAdd(-b) won't work, because this is the one number where
		// -b = b (so S17ToU71(-b) = 0).
		// TODO: is this correction always necessary?
		return a.SAdd(S17ToU71(MaxS17)).SAdd(1)
	}
	// If b is negative, add its absolute value instead.
	if b < 0 {
		return a.SAdd(S17ToU71(-b))
	}
	return a.SSub(S17ToU71(b))
}

// SMulS17 performs a saturating multiply between a U71
// and a S17, returning the result in a U71.
// As U71 is always positive, if b is negative the result will always
// be truncated to 0.
func (a U71) SMulS17(b S17) U71 {
	return U71(ussmul2(uint8(a), 1, int8(b), 7))
}

// end (U71, S17) -> U71
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (S17, U08) -> S17

// U08ToS17 converts a U08 to a S17.
// S17 has fewer fractional bits and therefore a wider range, so the
// result will be between 0 and 0.99609375 (rounding to a valid S17
// towards zero).
func U08ToS17(b U08) S17 {
	r := S17(b >> 1)
	// TODO: we don't need to do this if we shifted right.
	if r < 0 {
		r = 0
	}
	return r
}

// SAddU08 adds a S17 and a U08, storing the
// result in a S17.
func (a S17) SAddU08(b U08) S17 {
	return a.SAdd(U08ToS17(b))
}

func (a S17) SSubU08(b U08) S17 {
	return a.SSub(U08ToS17(b))
}

// SMulU08 performs a saturating multiply between a S17
// and a U08, returning the result in a S17.
func (a S17) SMulU08(b U08) S17 {
	return S17(susmul2(int8(a), 7, uint8(b), 8))
}

// end (S17, U08) -> S17
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (S17, U17) -> S17

// U17ToS17 converts a U17 to a S17.
// The two types have the same number of fractional bits, but as S17 is
// signed and U17 is not, the result will be positive but truncated
// at 0.9921875.
func U17ToS17(b U17) S17 {
	// S17 has a narrower range than U17.
	m := 0xff << (8 - 0 - 1)
	if b&U17(m) != 0 {
		return MaxS17
	}
	r := S17(b)
	// TODO: we don't need to do this if we shifted right.
	if r < 0 {
		r = 0
	}
	return r
}

// SAddU17 adds a S17 and a U17, storing the
// result in a S17.
func (a S17) SAddU17(b U17) S17 {
	return a.SAdd(U17ToS17(b))
}

func (a S17) SSubU17(b U17) S17 {
	m := 0xff << (8 - 0 - 1)
	if b&U17(m) != 0 {
		// Direct conversion will saturate, which means the result
		// will be wrong. To get the right answer (or as close as
		// we can) break the subtraction into two pieces. Two is
		// always enough because the largest possible value we can
		// subtract is the MinS17, which covers more than
		// half of the possible range of possible S17.
		a = a.SAdd(MinS17)
		b = b.SAddS17(MinS17)
	}
	return a.SSub(U17ToS17(b))
}

// SMulU17 performs a saturating multiply between a S17
// and a U17, returning the result in a S17.
func (a S17) SMulU17(b U17) S17 {
	return S17(susmul2(int8(a), 7, uint8(b), 7))
}

// end (S17, U17) -> S17
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// begin (S17, U71) -> S17

// U71ToS17 converts a U71 to a S17.
// S17 has more fractional bits and therefore a narrower range, so the
// result will be capped between -1 and 0.9921875.
func U71ToS17(b U71) S17 {
	// S17 has a narrower range than U71.
	m := 0xff << (8 - 6 - 1)
	if b&U71(m) != 0 {
		return MaxS17
	}
	r := S17(b << 6)
	// TODO: we don't need to do this if we shifted right.
	if r < 0 {
		r = 0
	}
	return r
}

// SAddU71 adds a S17 and a U71, storing the
// result in a S17.
func (a S17) SAddU71(b U71) S17 {
	return a.SAdd(U71ToS17(b))
}

func (a S17) SSubU71(b U71) S17 {
	m := 0xff << (8 - 6 - 1)
	if b&U71(m) != 0 {
		// Direct conversion will saturate, which means the result
		// will be wrong. To get the right answer (or as close as
		// we can) break the subtraction into two pieces. Two is
		// always enough because the largest possible value we can
		// subtract is the MinS17, which covers more than
		// half of the possible range of possible S17.
		a = a.SAdd(MinS17)
		b = b.SAddS17(MinS17)
	}
	return a.SSub(U71ToS17(b))
}

// SMulU71 performs a saturating multiply between a S17
// and a U71, returning the result in a S17.
func (a S17) SMulU71(b U71) S17 {
	return S17(susmul2(int8(a), 7, uint8(b), 1))
}

// end (S17, U71) -> S17
////////////////////////////////////////////////////////////////////////////////
