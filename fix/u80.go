// Code generated by by github.com/pfcm/fxp/fix/gen DO NOT EDIT.

package fix

import (
	"fmt"

	"golang.org/x/exp/constraints"
)

// U80 is an unsigned 8 bit fixed point number with 0
// fractional bits, representing numbers between 0 and 255, in steps
// of 0.99609375.
// It is just a standard uint8, but with saturating arithmetic and generated conversions
type U80 uint8

const (
	// MinU80 is the smallest U80: 0.
	MinU80 U80 = 0x00
	// MaxU80 is the largest U80: 255.
	MaxU80 U80 = 0xff
)

// U80ToFloat converts a U80 to a float value.
func U80ToFloat[T constraints.Float](u U80) T {
	return T(u) * 1
}

// U80FromFloat returns the nearest U80 to the provided
// float value.
func U80FromFloat[T constraints.Float](f T) U80 {
	if f < 0 {
		return 0
	}
	if f > 255 {
		return 0xff
	}
	// TODO: rounding? Then we would have to do it in SMul etc.
	return U80((f /*+0.498046875*/) * 1)
}

// String returns a string representation of a U80.
func (u U80) String() string {
	return fmt.Sprintf("%.1f", U80ToFloat[float64](u))
}

// SAdd is a saturating addition betwenn two U80.
func (u U80) SAdd(v U80) U80 {
	return U80(usadd(uint8(u), uint8(v)))
}

// SSub is a saturating subtraction between two U80,
// subtracting v from u.
func (u U80) SSub(v U80) U80 {
	return U80(ussub(uint8(u), uint8(v)))
}

// SMul is a saturating multiply between two U80.
func (u U80) SMul(v U80) U80 {
	return U80(usmul(uint8(u), uint8(v), 0))
}
